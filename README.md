### 单例模式
单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

注意：

1、单例类只能有一个实例。
2、单例类必须自己创建自己的唯一实例。
3、单例类必须给所有其他对象提供这一实例。


### 工厂模式
工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。


### 模板模式
在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。

### 责任链模式
顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。

在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

### 外观模式
外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

### 适配器模式

#### 特点：

 *  适配器继承或依赖已有的对象，实现想要的目标接口
 *  消除由于接口不匹配所造成的类的兼容性问题
 *  类的适配器模式、对象的适配器模式、接口的适配器模式
 *  提高了类的复用，增加了类的透明度

#### 案例
mybatis的log模块

### 装饰器模式

#### 特点：装饰类持有原有类或接口的对象，并调用它的方法
 *  通过一个装饰类对现有类对象动态添加一些功能，同时不改变其结构
 *  动态添加，动态撤销
 *  继承的替代方式，继承只能静态添加
 *  多成装饰产生过多相似对象，复杂且不易排错
 
#### 案例
mybatis的cache


### 代理模式
#### 注意事项：
 *  和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。
 *  和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。


### 观察者模式

#### 特点
 *  类和类之间的关系
 *  对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新


### 策略模式

#### 特点
 *  多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护
 *  在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为

#### 缺点
 *  策略类会增多，所有策略类都需要对外暴露
